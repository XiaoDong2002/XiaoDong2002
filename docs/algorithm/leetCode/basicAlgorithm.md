## 递归算法

递归算法是一种函数调用自身的算法，常用于解决需要重复执行相同或相似任务的问题

在递归算法中，函数会将问题分解成更小的子问题，然后递归地解决这些子问题，最终将所有子问题的结果组合起来得到原始问题的解。

递归算法通常具有以下特征：

基本情况：算法必须包含一个基本情况，即递归调用停止的条件，否则会导致无限递归

递归调用：算法通过调用自身来解决问题的过程。

问题规模的减小：每次递归调用时，问题的规模都应该比上一次递归调用时小

结果组合：递归调用返回的结果应该被组合起来，得到原始问题的解

递归算法通常比较简洁、优雅，但也可能会导致栈溢出等问题，需要谨慎使用

下面是一个用JavaScript实现的递归算法的例子，它可以计算阶乘（factorial）：

```js
function factorial(n) {
  if (n == 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

// 这个函数的基本情况是当n等于0时直接返回1，因为0的阶乘是1。对于其他情况，
// 函数使用递归调用来计算n的阶乘，即n乘以(n-1)的阶乘。递归调用将问题分解成更小的子问题，
// 直到最终达到基本情况。最后，所有子问题的结果将被组合起来得到原始问题的解，即n的阶乘。

// 例如，如果调用factorial(5)，它将返回5乘以4乘以3乘以2乘以1，即120。
```







## 枚举算法

枚举算法（Enumeration algorithm）是一种穷举所有可能情况的算法，它通过列举出所有可能的解决方案，

逐一检查它们是否符合问题的条件，从而找到问题的解。在实践中，枚举算法常常用于求解小规模的问题。

枚举算法通常有以下特征：

枚举范围：算法需要确定问题的所有可能解的范围。

枚举方式：算法需要确定如何列举所有可能的解决方案。

判断条件：算法需要确定每个解决方案是否符合问题的条件。

枚举算法的优点是简单易懂、通用性强，可以解决许多问题，但也有缺点，就是当问题规模较大时，

枚举算法的运算速度较慢，而且可能会浪费大量的计算资源。

一个简单的枚举算法的例子是查找数组中的最大值和最小值。它可以通过遍历数组中的所有元素，

依次比较它们的大小，最终找到数组中的最大值和最小值。



下面是一个用JavaScript实现的枚举算法的例子，它可以查找一个数组中的最大值和最小值：

```js
function findMaxAndMin(array) {
  var max = array[0];
  var min = array[0];
  for (var i = 1; i < array.length; i++) {
    if (array[i] > max) {
      max = array[i];
    }
    if (array[i] < min) {
      min = array[i];
    }
  }
  return { max: max, min: min };
}

// 这个函数首先假设数组中的第一个元素是最大值和最小值，
// 然后遍历整个数组，逐个比较每个元素的大小，
// 更新最大值和最小值。最后，函数返回一个包含最大值和最小值的对象。

// 例如，如果调用findMaxAndMin([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])，
// 它将返回{ max: 9, min: 1 }，即数组中的最大值是9，最小值是1。
```





## 贪心算法

贪心算法（Greedy algorithm）是一种通过每个阶段的局部最优选择来达到全局最优解的算法。

在贪心算法中，每一步都采取当前状态下最好的选择，而不考虑其对未来决策的影响。

通常来说，贪心算法可以通过贪心选择性质、最优子结构性质和无后效性等特性来设计。

贪心算法通常有以下步骤：

确定问题的最优子结构：将原问题划分为若干个子问题，每个子问题的解都可以作为原问题的解，

而且它们之间是相互独立的。
建立贪心选择性质：确定每个子问题的最优解策略，保证每个子问题的最优解可以通过当前状态下的最优选择获得。

确定贪心算法的边界条件：确定贪心算法的起始状态和终止条件。

实现贪心算法：根据贪心选择策略，从初始状态开始，逐步求解出整个问题的最优解。

贪心算法的优点是简单高效，适用于很多优化问题，但它也有缺点，就是它不能保证一定能得到全局最优解，

因为它每个阶段只考虑了局部最优解，而没有考虑全局的情况。

一个经典的贪心算法的例子是找零钱问题。在这个问题中，假设有一定面值的硬币，

需要用最少的硬币数来找出一个给定的数值。

贪心算法的策略是在每个阶段选择当前面值能够找出的最大硬币数，直到找完整个数值。

下面是一个用JavaScript实现的贪心算法的例子，它可以用最少的硬币数找出一个给定的数值：

```js
function findMinCoins(coins, value) {
  coins.sort(function(a, b) { return b - a; }); // 将硬币面值按降序排列
  var result = [];
  for (var i = 0; i < coins.length; i++) {
    while (value >= coins[i]) { // 不断将面值最大的硬币加入结果，直到总面值等于目标值
      value -= coins[i];
      result.push(coins[i]);
    }
  }
  return result;
}

// 这个函数首先将硬币面值按降序排列，然后从面值最大的硬币开始，
// 不断将面值最大的硬币加入结果，直到总面值等于目标值。在这个过程中，
// 由于选择了面值最大的硬币，所以需要的硬币数就是最少的。

// 例如，如果调用findMinCoins([1, 5, 10, 25], 72)，它将返回[25, 25, 10, 10, 1, 1]，
// 即用最少的硬币数找出72美分需要用两个25美分硬币、两个10美分硬币和两个1美分硬币。
```





## 回溯算法

回溯算法是一种穷举算法，它通过逐步构建可能的解决方案，并在构建的过程中进行剪枝，

来找到所有符合要求的解决方案。在回溯算法中，每一步的决策都可能影响后续的决策，

因此需要在每一步的决策之后判断是否满足要求，如果不满足要求就撤销当前的决策并回到上一步，

然后继续尝试其他的决策，直到找到符合要求的解决方案或者穷举完所有可能的解决方案。

回溯算法通常用于解决组合优化问题、排列问题、搜索问题、游戏问题等一些需要求解所有可能的解决方案的问题，

但由于其时间复杂度很高，因此需要对算法进行优化，例如通过剪枝等技巧来减少搜索空间。

常见的回溯算法包括八皇后问题、0/1背包问题、全排列问题、数独问题等





## 分治算法

待更新...2023/03/22



## 动态规划
